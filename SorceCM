
 local util = loadstring(game:HttpGet("https://raw.githubusercontent.com/Awakenchan/BypassUtil/main/BypassUtils"))()
-- ============================================
-- COMPATIBILITY TEST (0-10 Score)
-- ============================================
local function runCompatibilityTest()
    local score = 0
    local maxScore = 10
    local issues = {}
    
    -- Test 1: LocalPlayer exists (2 points)
    if game:GetService("Players").LocalPlayer then
        score = score + 2
    else
        table.insert(issues, "LocalPlayer not found")
    end
    
    -- Test 2: ReplicatedStorage accessible (1 point)
    if pcall(function() return game:GetService("ReplicatedStorage") end) then
        score = score + 1
    else
        table.insert(issues, "ReplicatedStorage not accessible")
    end
    
    -- Test 3: Workspace accessible (1 point)
    if pcall(function() return workspace end) then
        score = score + 1
    else
        table.insert(issues, "Workspace not accessible")
    end
    
    -- Test 4: RunService available (1 point)
    if pcall(function() return game:GetService("RunService") end) then
        score = score + 1
    else
        table.insert(issues, "RunService not available")
    end
    
    -- Test 5: HttpGet functional (1 point)
    local httpSuccess = pcall(function()
        game:HttpGet("https://raw.githubusercontent.com/TawainBailey/REFACTOR/refs/heads/main/SorceCM")
    end)
    if httpSuccess then
        score = score + 1
    else
        table.insert(issues, "HttpGet blocked or not functional")
    end
    
    -- Test 6: Required game elements exist (2 points)
    local elementsFound = 0
    if pcall(function() return workspace:FindFirstChild("Living") end) then elementsFound = elementsFound + 1 end
    if pcall(function() return workspace:FindFirstChild("Rocks") end) then elementsFound = elementsFound + 1 end
    score = score + elementsFound
    if elementsFound < 2 then
        table.insert(issues, string.format("Game elements missing (%d/2 found)", elementsFound))
    end
    
    -- Test 7: Character manipulation possible (2 points)
    local player = game:GetService("Players").LocalPlayer
    if player and player.Character then
        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            score = score + 2
        else
            score = score + 1
            table.insert(issues, "HumanoidRootPart not found")
        end
    else
        table.insert(issues, "Character not loaded")
    end
    
    -- Display results
    local resultMessage = string.format(
        "=== COMPATIBILITY TEST ===\nScore: %d/%d\nExecutor: %s\n",
        score, maxScore,
        identifyexecutor and identifyexecutor() or "Unknown"
    )
    
    if #issues > 0 then
        resultMessage = resultMessage .. "\nIssues detected:\n"
        for i, issue in ipairs(issues) do
            resultMessage = resultMessage .. string.format("  %d. %s\n", i, issue)
        end
    end
    
    if score >= 8 then
        resultMessage = resultMessage .. "\nStatus: EXCELLENT - Script will work perfectly"
    elseif score >= 6 then
        resultMessage = resultMessage .. "\nStatus: GOOD - Script should work with minor issues"
    elseif score >= 4 then
        resultMessage = resultMessage .. "\nStatus: FAIR - Some features may not work"
    else
        resultMessage = resultMessage .. "\nStatus: POOR - Script likely won't work properly"
    end
    
    resultMessage = resultMessage .. "\n========================="
    
    warn(resultMessage)
    return score
end

-- Run test before loading
local compatScore = runCompatibilityTest()

local Compkiller = loadstring(game:HttpGet("https://raw.githubusercontent.com/TawainBailey/REFACTOR/refs/heads/main/SorceCM"))();
local Notifier = Compkiller and Compkiller.newNotify() or nil

-- Align colors with Basic theme (gradient/highlights/toggles)
if Compkiller and Compkiller.Colors then
    Compkiller.Colors.Highlight = Color3.fromRGB(0, 153, 255) -- #0099ff
    Compkiller.Colors.Toggle = Color3.fromRGB(0, 153, 255) -- #0099ff
    Compkiller.Colors.MouseEnter = Color3.fromRGB(61, 61, 117) -- #3D3D75
    -- Apply the new colors to the UI
    pcall(function() Compkiller:RefreshCurrentColor() end)
end

-- Show Compkiller loader/gradient similar to Basic
if Compkiller and type(Compkiller.Loader) == "function" then
    pcall(function() Compkiller:Loader("rbxassetid://135708772784005", 1.5).yield() end)
end

-- Helper to create the main Basic window + UI
local function createMainUI()
    -- create Window & tabs
    local Window = Compkiller.new({
        Name = "Vex",
        Keybind = "LeftAlt",
        Logo = "rbxassetid://135708772784005",
        Scale = Compkiller.Scale.Window,
        TextSize = 15,
    })
    local MainTab = Window:DrawTab({ Name = "Main", Icon = "lucide-menu" })
    Window:DrawCategory({ Name = "Misc" })
    local Settings = Window:DrawTab({ Name = "Settings", Icon = "rbxassetid://97519285421665", Type = "Single", EnableScrolling = true })
    local ScriptControlSection = Settings:DrawSection({ Name = "Script Control" })
    local stopAutoPump = nil

    ScriptControlSection:AddButton({
        Name = "Unload Script",
        Callback = function()
            if Notifier then
                Notifier.new({ Title = "Script Unloaded", Content = "All features stopped and UI destroyed", Duration = 2, Icon = "95448792622941" })
            end
            -- Stop features if they exist, then destroy
            pcall(function()
                if stopAutoPump then pcall(stopAutoPump) end
            end)
            pcall(function() Window:Destroy() end)
        end
    })

    -- UI Settings Section
    local UISettings = Settings:DrawSection({ Name = "UI Settings" })
    UISettings:AddToggle({ Name = "Always Show Frame", Default = true, Callback = function(v) Window.AlwayShowTab = v end })

    UISettings:AddColorPicker({ Name = "Highlight", Default = Compkiller.Colors.Highlight, Callback = function(v) Compkiller.Colors.Highlight = v; Compkiller:RefreshCurrentColor() end })
    UISettings:AddColorPicker({ Name = "Toggle Color", Default = Compkiller.Colors.Toggle, Callback = function(v) Compkiller.Colors.Toggle = v; Compkiller:RefreshCurrentColor(v) end })
    UISettings:AddColorPicker({ Name = "Drop Color", Default = Compkiller.Colors.DropColor, Callback = function(v) Compkiller.Colors.DropColor = v; Compkiller:RefreshCurrentColor(v) end })
    UISettings:AddColorPicker({ Name = "Risky", Default = Compkiller.Colors.Risky, Callback = function(v) Compkiller.Colors.Risky = v; Compkiller:RefreshCurrentColor(v) end })
    UISettings:AddColorPicker({ Name = "Mouse Enter", Default = Compkiller.Colors.MouseEnter, Callback = function(v) Compkiller.Colors.MouseEnter = v; Compkiller:RefreshCurrentColor(v) end })
    UISettings:AddColorPicker({ Name = "Block Color", Default = Compkiller.Colors.BlockColor, Callback = function(v) Compkiller.Colors.BlockColor = v; Compkiller:RefreshCurrentColor(v) end })
    UISettings:AddColorPicker({ Name = "Background Color", Default = Compkiller.Colors.BGDBColor, Callback = function(v) Compkiller.Colors.BGDBColor = v; Compkiller:RefreshCurrentColor(v) end })
    UISettings:AddColorPicker({ Name = "Block Background Color", Default = Compkiller.Colors.BlockBackground, Callback = function(v) Compkiller.Colors.BlockBackground = v; Compkiller:RefreshCurrentColor(v) end })
    UISettings:AddColorPicker({ Name = "Stroke Color", Default = Compkiller.Colors.StrokeColor, Callback = function(v) Compkiller.Colors.StrokeColor = v; Compkiller:RefreshCurrentColor(v) end })
    UISettings:AddColorPicker({ Name = "High Stroke Color", Default = Compkiller.Colors.HighStrokeColor, Callback = function(v) Compkiller.Colors.HighStrokeColor = v; Compkiller:RefreshCurrentColor(v) end })
    UISettings:AddColorPicker({ Name = "Switch Color", Default = Compkiller.Colors.SwitchColor, Callback = function(v) Compkiller.Colors.SwitchColor = v; Compkiller:RefreshCurrentColor(v) end })
    UISettings:AddColorPicker({ Name = "Line Color", Default = Compkiller.Colors.LineColor, Callback = function(v) Compkiller.Colors.LineColor = v; Compkiller:RefreshCurrentColor(v) end })

    UISettings:AddButton({ Name = "Get Theme", Callback = function()
        local theme = Compkiller:GetTheme()
        setclipboard(theme)
        if Notifier then Notifier.new({ Title = "Theme", Content = "Copied Theme Color to your clipboard", Duration = 3, Icon = "95448792622941" }) end
    end })

    -- Theme Section (in Settings)
    local ThemeSection = Settings:DrawSection({ Name = "UI Themes" })
    ThemeSection:AddDropdown({ Name = "Select Theme", Default = "Default", Values = {"Default","Dark Green","Dark Blue","Purple Rose","Skeet"}, Callback = function(v) Compkiller:SetTheme(v) end })

    -- Mobile toggle for demo
    local mobileScreenGui, mobileButton
    local function cleanupMobileButton()
        pcall(function()
            local coreGui = game:GetService("CoreGui")
            local playerGui = game:GetService("Players").LocalPlayer.PlayerGui
            for _, child in pairs(coreGui:GetChildren()) do if child.Name == "FishitMobileToggle" then child:Destroy() end end
            for _, child in pairs(playerGui:GetChildren()) do if child.Name == "FishitMobileToggle" then child:Destroy() end end
        end)
    end

    local function createMobileToggle()
        cleanupMobileButton()
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "FishitMobileToggle"
        screenGui.ResetOnSpawn = false
        pcall(function() screenGui.Parent = game:GetService("CoreGui") end)
        if not screenGui.Parent then screenGui.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui") end
        mobileScreenGui = screenGui
        local btn = Instance.new("ImageButton")
        btn.Name = "ToggleButton"
        btn.Size = UDim2.new(0, 45, 0, 45)
        btn.Position = UDim2.new(0, 20, 0, 100)
        btn.BackgroundTransparency = 0.3
        btn.Image = "rbxassetid://124176341762168"
        btn.Parent = screenGui
        mobileButton = btn
    end

    -- Mobile Toggle option in a new section
    local MobileSection = Settings:DrawSection({ Name = "Mobile" })
    MobileSection:AddToggle({ Name = "Mobile Toggle Button", Default = false, Callback = function(Value)
        if Value then createMobileToggle() else cleanupMobileButton() end
    end })

    -- Main tab is intentionally empty; this is the central tab for the UI

    -- ============================================
    -- THEME TAB (theme controls)
    -- ============================================
    local ThemeTab = Window:DrawTab({ Name = "Themes", Icon = "paintbrush", Type = "Single" })
    local ThemeTabSection = ThemeTab:DrawSection({ Name = "Theme Controls" })
    ThemeTabSection:AddDropdown({ Name = "Select Theme", Default = "Default", Values = {"Default","Dark Green","Dark Blue","Purple Rose","Skeet"}, Callback = function(v) Compkiller:SetTheme(v) end })
    ThemeTabSection:AddColorPicker({ Name = "Highlight", Default = Compkiller.Colors.Highlight, Callback = function(v) Compkiller.Colors.Highlight = v; Compkiller:RefreshCurrentColor() end })
    ThemeTabSection:AddColorPicker({ Name = "Toggle Color", Default = Compkiller.Colors.Toggle, Callback = function(v) Compkiller.Colors.Toggle = v; Compkiller:RefreshCurrentColor(v) end })
    ThemeTabSection:AddButton({ Name = "Apply Theme", Callback = function()
        if Notifier then Notifier.new({ Title = "Theme", Content = "Applied theme changes (demo)", Duration = 2, Icon = "95448792622941" }) end
    end })

    -- MainTab is intentionally empty; nothing to show here

    -- ============================================
    -- CONFIG TAB (using Compkiller ConfigManager)
    -- ============================================
    local ConfigManager = Compkiller:ConfigManager({ Directory = "Basic", Config = "Basic-Configs" })
    local ConfigUI = Window:DrawConfig({ Name = "Config", Icon = "folder", Config = ConfigManager })
    pcall(function() ConfigUI:Init() end)

    -- ============================================
    -- MOBS Section in MAIN tab
    -- ============================================
    local MobsSection = MainTab:DrawSection({ Name = "Mobs" })
    
    local selectedMobs = {}
    
    MobsSection:AddDropdown({
        Name = "Target Mobs",
        Flag = "Mobs_TargetMobs",
        Default = {},
        Multi = true,
        Values = {
            "Zombie",
            "Elite Zombie",
            "Delver Zombie",
            "Brute Zombie",
            "Bomber",
            "Skeleton Rogue",
            "Axe Skeleton",
            "Deathaxe Skeleton",
            "Elite Rogue Skeleton",
            "Elite Deathaxe Skeleton",
            "Reaper",
            "Slime",
            "Blazing Slime"
        },
        Callback = function(selected)
            selectedMobs = selected
        end
    })
    
    local autoKillEnabled = false
    local autoKillConnection = nil
    local noclipConnection = nil
    local movementSpeed = 16
    local distanceOffset = 5
    local heightOffset = 0
    
    local function startAutoKill()
        if autoKillConnection then autoKillConnection:Disconnect() end
        if noclipConnection then noclipConnection:Disconnect() end
        
        -- Enable full noclip
        noclipConnection = game:GetService("RunService").Stepped:Connect(function()
            if not autoKillEnabled then return end
            
            pcall(function()
                local player = game:GetService("Players").LocalPlayer
                local character = player.Character
                if not character then return end
                
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.PlatformStand = false
                end
                
                -- Disable collision on ALL parts including legs, arms, torso, head, etc.
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") or part:IsA("Part") or part:IsA("MeshPart") then
                        part.CanCollide = false
                        part.Velocity = Vector3.new(0, 0, 0)
                        part.RotVelocity = Vector3.new(0, 0, 0)
                    end
                end
                
                -- Also disable collision on accessories
                for _, accessory in pairs(character:GetChildren()) do
                    if accessory:IsA("Accessory") then
                        local handle = accessory:FindFirstChild("Handle")
                        if handle and handle:IsA("BasePart") then
                            handle.CanCollide = false
                        end
                    end
                end
            end)
        end)
        
        autoKillConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if not autoKillEnabled then return end
            
            pcall(function()
                local player = game:GetService("Players").LocalPlayer
                local character = player.Character
                if not character then return end
                
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChild("Humanoid")
                if not humanoid or not humanoidRootPart then return end
                
                local living = workspace:FindFirstChild("Living")
                if not living then return end
                
                -- Find closest mob that matches selected names
                local closestMob = nil
                local closestDistance = math.huge
                
                for _, mobModel in pairs(living:GetChildren()) do
                    if mobModel:IsA("Model") and mobModel:GetAttribute("IsNpc") then
                        -- Check if mob is alive
                        local mobHumanoid = mobModel:FindFirstChildOfClass("Humanoid")
                        if not mobHumanoid or mobHumanoid.Health <= 0 then
                            continue
                        end
                        
                        local mobName = mobModel.Name
                        -- Strip numbers from end of name (e.g., "Zombie12345" -> "Zombie")
                        local baseName = mobName:match("^(.-)%d*$") or mobName
                        
                        for selectedName, isSelected in pairs(selectedMobs) do
                            -- Only match if the base name EXACTLY matches the selected name
                            if isSelected and baseName == selectedName then
                                local mobPivot = mobModel:GetPivot()
                                if mobPivot then
                                    local distance = (mobPivot.Position - humanoidRootPart.Position).Magnitude
                                    if distance < closestDistance then
                                        closestDistance = distance
                                        closestMob = mobModel
                                    end
                                end
                                break
                            end
                        end
                    end
                end
                
                if closestMob then
                    -- Re-check if mob is still alive
                    local mobHumanoid = closestMob:FindFirstChildOfClass("Humanoid")
                    if not mobHumanoid or mobHumanoid.Health <= 0 then
                        return
                    end
                    
                    local mobPivot = closestMob:GetPivot()
                    local mobPosition = mobPivot.Position
                    local mobLookVector = mobPivot.LookVector
                    
                    -- Lock position to mob: stay at distance offset behind mob's facing direction, with height offset
                    local targetPosition = mobPosition - (mobLookVector * distanceOffset) + Vector3.new(0, heightOffset, 0)
                    
                    -- Calculate distance to target
                    local distance = (targetPosition - humanoidRootPart.Position).Magnitude
                    
                    -- Move based on movement speed slider (studs per second)
                    local frameSpeed = movementSpeed / 60  -- Convert to per-frame speed
                    
                    -- Smoothly move to target or snap if very close
                    local newPosition
                    if distance > frameSpeed then
                        local moveDirection = (targetPosition - humanoidRootPart.Position).Unit
                        newPosition = humanoidRootPart.Position + (moveDirection * frameSpeed)
                    else
                        newPosition = targetPosition
                    end
                    
                    -- Face the mob while moving
                    humanoidRootPart.CFrame = CFrame.new(newPosition, mobPosition)
                    
                    -- Clear all velocities to prevent physics interference
                    humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                    humanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
                    humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    humanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    
                    -- Only attack when close to target position
                    if distance <= frameSpeed * 2 then
                        pcall(function()
                            local args = {"Weapon"}
                            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated"):InvokeServer(unpack(args))
                        end)
                    end
                end
            end)
        end)
    end
    
    local function stopAutoKill()
        if autoKillConnection then
            autoKillConnection:Disconnect()
            autoKillConnection = nil
        end
        
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
        
        -- Reset movement speed and collision
        pcall(function()
            local player = game:GetService("Players").LocalPlayer
            if player.Character then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.WalkSpeed = 16
                    humanoid.PlatformStand = false
                end
                
                -- Re-enable collision
                for _, part in pairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
        end)
    end
    
    MobsSection:AddToggle({
        Name = "Auto Kill",
        Flag = "Mobs_AutoKill",
        Default = false,
        Callback = function(v)
            autoKillEnabled = v
            if v then
                startAutoKill()
            else
                stopAutoKill()
            end
        end
    })
    
    -- Farming Section
    local FarmingSection = MainTab:DrawSection({ Name = "Farming Settings" })
    
    FarmingSection:AddSlider({
        Name = "Movement Speed",
        Min = 1,
        Max = 300,
        Default = 16,
        Round = 0,
        Flag = "Farming_MovementSpeed",
        Callback = function(value)
            movementSpeed = value
        end
    })
    
    FarmingSection:AddSlider({
        Name = "Distance Offset",
        Min = -10,
        Max = 20,
        Default = 5,
        Round = 0,
        Flag = "Farming_DistanceOffset",
        Callback = function(value)
            distanceOffset = value
        end
    })
    
    FarmingSection:AddSlider({
        Name = "Height Offset",
        Min = -10,
        Max = 10,
        Default = 0,
        Round = 0,
        Flag = "Farming_HeightOffset",
        Callback = function(value)
            heightOffset = value
        end
    })

    -- ============================================
    -- TELEPORT Section in MAIN tab
    -- ============================================
    local TeleportSection = MainTab:DrawSection({ Name = "Teleport" })
    
    local npcLocations = {
        ["Arcane Pickaxe"] = CFrame.new(234.41, -14.00, -336.50),
        ["AttackDamagePotion1"] = CFrame.new(-145.43, 27.06, 110.88),
        ["Bard"] = CFrame.new(-130.75, 27.79, 109.65),
        ["BardGuitar"] = CFrame.new(-50.32, -24.89, -60.04),
        ["Bronze Pickaxe"] = CFrame.new(-80.23, 28.27, 83.95),
        ["Tomo"] = CFrame.new(-105.48, 49.67, -107.67),
        ["Enhancer"] = CFrame.new(-260.63, 19.85, 25.23),
        ["FallenAngelCaveDoor"] = CFrame.new(240.36, -13.76, -251.70),
        ["Forge"] = CFrame.new(-192.03, 29.47, 167.17),
        ["Gold Pickaxe"] = CFrame.new(-95.75, 28.71, 100.07),
        ["Greedy Cey"] = CFrame.new(-112.75, 37.52, -37.29),
        ["Health Potion 1"] = CFrame.new(-147.42, 27.48, 111.64),
        ["Injured miner"] = CFrame.new(81.56, -14.59, -364.29),
        ["Iron Pickaxe"] = CFrame.new(-82.60, 28.56, 85.53),
        ["Lucky Potion 1"] = CFrame.new(-162.46, 27.50, 120.60),
        ["Marbles"] = CFrame.new(-179.95, 28.66, 13.30),
        ["Maria"] = CFrame.new(-152.60, 27.99, 119.28),
        ["Miner Fred"] = CFrame.new(-89.50, 28.32, 92.21),
        ["Miner Potion 1"] = CFrame.new(-159.94, 27.73, 118.73),
        ["SpeedPotion1"] = CFrame.new(-149.44, 27.61, 112.44),
        ["Nord"] = CFrame.new(39.48, -5.51, -104.70),
        ["Platinum Pickaxe"] = CFrame.new(-98.66, 28.71, 101.64),
        ["Runemaker"] = CFrame.new(-271.49, 20.32, 145.91),
        ["Sensei Moro"] = CFrame.new(-199.23, 29.47, 157.81),
        ["Simple Lantern"] = CFrame.new(-122.38, 30.91, 115.24),
        ["Stonewakes Pickaxe"] = CFrame.new(-34.68, -1.08, -267.71),
        ["Suspescous Fisher"] = CFrame.new(-297.44, 23.83, -91.97),
        ["Unut The Brave"] = CFrame.new(11.54, -5.90, -118.75),
        ["Undead"] = CFrame.new(-45.65, -26.67, -59.68),
        ["Wizard"] = CFrame.new(-23.56, 80.88, -357.69)
    }
    
    local selectedNpc = nil
    local moveToNpcConnection = nil
    local moveNoclipConnection = nil
    
    TeleportSection:AddDropdown({
        Name = "Select NPC",
        Flag = "Teleport_SelectNPC",
        Default = "Forge",
        Values = {
            "Arcane Pickaxe",
            "AttackDamagePotion1",
            "Bard",
            "BardGuitar",
            "Bronze Pickaxe",
            "Tomo",
            "Enhancer",
            "FallenAngelCaveDoor",
            "Forge",
            "Gold Pickaxe",
            "Greedy Cey",
            "Health Potion 1",
            "Injured miner",
            "Iron Pickaxe",
            "Lucky Potion 1",
            "Marbles",
            "Maria",
            "Miner Fred",
            "Miner Potion 1",
            "SpeedPotion1",
            "Nord",
            "Platinum Pickaxe",
            "Runemaker",
            "Sensei Moro",
            "Simple Lantern",
            "Stonewakes Pickaxe",
            "Suspescous Fisher",
            "Unut The Brave",
            "Undead",
            "Wizard"
        },
        Callback = function(value)
            selectedNpc = value
        end
    })
    
    TeleportSection:AddButton({
        Name = "Move to Npc",
        Callback = function()
            if not selectedNpc or not npcLocations[selectedNpc] then
                if Notifier then
                    Notifier.new({ Title = "Error", Content = "Please select an NPC first", Duration = 2, Icon = "95448792622941" })
                end
                return
            end
            
            -- Stop any existing movement
            if moveToNpcConnection then
                moveToNpcConnection:Disconnect()
                moveToNpcConnection = nil
            end
            if moveNoclipConnection then
                moveNoclipConnection:Disconnect()
                moveNoclipConnection = nil
            end
            
            local targetCFrame = npcLocations[selectedNpc]
            local targetPosition = targetCFrame.Position
            
            -- Enable noclip during movement
            moveNoclipConnection = game:GetService("RunService").Stepped:Connect(function()
                pcall(function()
                    local player = game:GetService("Players").LocalPlayer
                    local character = player.Character
                    if not character then return end
                    
                    local humanoid = character:FindFirstChild("Humanoid")
                    if humanoid then
                        humanoid.PlatformStand = false
                    end
                    
                    -- Disable collision on ALL parts
                    for _, part in pairs(character:GetDescendants()) do
                        if part:IsA("BasePart") or part:IsA("Part") or part:IsA("MeshPart") then
                            part.CanCollide = false
                            part.Velocity = Vector3.new(0, 0, 0)
                            part.RotVelocity = Vector3.new(0, 0, 0)
                        end
                    end
                    
                    -- Disable collision on accessories
                    for _, accessory in pairs(character:GetChildren()) do
                        if accessory:IsA("Accessory") then
                            local handle = accessory:FindFirstChild("Handle")
                            if handle and handle:IsA("BasePart") then
                                handle.CanCollide = false
                            end
                        end
                    end
                end)
            end)
            
            -- Start moving to NPC
            moveToNpcConnection = game:GetService("RunService").Heartbeat:Connect(function()
                pcall(function()
                    local player = game:GetService("Players").LocalPlayer
                    local character = player.Character
                    if not character then return end
                    
                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                    if not humanoidRootPart then return end
                    
                    local currentPosition = humanoidRootPart.Position
                    local distance = (targetPosition - currentPosition).Magnitude
                    
                    -- Movement speed of 50 studs per second
                    local frameSpeed = 50 / 60
                    
                    if distance > frameSpeed then
                        -- Move towards target
                        local direction = (targetPosition - currentPosition).Unit
                        local newPosition = currentPosition + (direction * frameSpeed)
                        humanoidRootPart.CFrame = CFrame.new(newPosition, targetPosition)
                        
                        -- Clear velocities
                        humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                        humanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
                        humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        humanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    else
                        -- Reached destination
                        humanoidRootPart.CFrame = targetCFrame
                        
                        -- Stop movement and noclip
                        if moveToNpcConnection then
                            moveToNpcConnection:Disconnect()
                            moveToNpcConnection = nil
                        end
                        if moveNoclipConnection then
                            moveNoclipConnection:Disconnect()
                            moveNoclipConnection = nil
                        end
                        
                        -- Re-enable collision
                        pcall(function()
                            local player = game:GetService("Players").LocalPlayer
                            if player.Character then
                                for _, part in pairs(player.Character:GetDescendants()) do
                                    if part:IsA("BasePart") then
                                        part.CanCollide = true
                                    end
                                end
                            end
                        end)
                        
                        if Notifier then
                            Notifier.new({ Title = "Arrived", Content = "Reached " .. selectedNpc, Duration = 2, Icon = "95448792622941" })
                        end
                    end
                end)
            end)
            
            if Notifier then
                Notifier.new({ Title = "Moving", Content = "Moving to " .. selectedNpc, Duration = 2, Icon = "95448792622941" })
            end
        end
    })

    -- ============================================
    -- MINING Section in MAIN tab
    -- ============================================
    local MiningSection = MainTab:DrawSection({ Name = "Mining" })
    
    local priorityRocks = {}
    local otherRocks = {}
    local autoMineEnabled = false
    local autoMineConnection = nil
    local miningNoclipConnection = nil
    
    -- All rocks in the game
    local allRocks = {
        "Pebble",
        "Rock", 
        "Boulder",
        "Basalt Rock",
        "Basalt Core",
        "Basalt Vein",
        "Volcanic Rock",
        "Crimson Crystal",
        "Cyan Crystal",
        "Earth Crystal",
        "Light Crystal",
        "Violet Crystal"
    }
    
    MiningSection:AddDropdown({
        Name = "Priority Rock",
        Flag = "Mining_PriorityRock",
        Default = {},
        Multi = true,
        Values = allRocks,
        Callback = function(selected)
            priorityRocks = selected
        end
    })
    
    MiningSection:AddDropdown({
        Name = "Select Other Rock",
        Flag = "Mining_OtherRock",
        Default = {},
        Multi = true,
        Values = allRocks,
        Callback = function(selected)
            otherRocks = selected
        end
    })
    
    local function findClosestRock(selectedRocks)
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character
        if not character then return nil end
        
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return nil end
        
        local rocksFolder = workspace:FindFirstChild("Rocks")
        if not rocksFolder then return nil end
        
        local closestRock = nil
        local closestDistance = math.huge
        local closestSpawnLocation = nil
        
        -- Search through all rock area folders
        local rockAreas = {"Island1CaveDeep", "Island1CaveMid", "Island1CaveStart", "Roof"}
        
        for _, areaName in pairs(rockAreas) do
            local area = rocksFolder:FindFirstChild(areaName)
            if area then
                for _, spawnLocation in pairs(area:GetChildren()) do
                    if spawnLocation:IsA("BasePart") and spawnLocation.Name == "SpawnLocation" then
                        -- Check if this spawn location has rocks with health > 0
                        local hasValidRock = false
                        for _, child in pairs(spawnLocation:GetChildren()) do
                            if child:IsA("Model") then
                                local rockName = child.Name
                                local rockHealth = child:GetAttribute("Health")
                                
                                -- Check if this rock is in our selected list AND has health > 0
                                for selectedName, isSelected in pairs(selectedRocks) do
                                    if isSelected and rockName == selectedName and rockHealth and rockHealth > 0 then
                                        hasValidRock = true
                                        break
                                    end
                                end
                                if hasValidRock then break end
                            end
                        end
                        
                        if hasValidRock then
                            local distance = (spawnLocation.Position - humanoidRootPart.Position).Magnitude
                            if distance < closestDistance then
                                closestDistance = distance
                                closestRock = spawnLocation
                                closestSpawnLocation = spawnLocation
                            end
                        end
                    end
                end
            end
        end
        
        return closestSpawnLocation
    end
    
    local function startAutoMine()
        if autoMineConnection then autoMineConnection:Disconnect() end
        if miningNoclipConnection then miningNoclipConnection:Disconnect() end
        
        -- Enable noclip
        miningNoclipConnection = game:GetService("RunService").Stepped:Connect(function()
            if not autoMineEnabled then return end
            
            pcall(function()
                local player = game:GetService("Players").LocalPlayer
                local character = player.Character
                if not character then return end
                
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.PlatformStand = false
                end
                
                -- Disable collision on ALL parts
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") or part:IsA("Part") or part:IsA("MeshPart") then
                        part.CanCollide = false
                        part.Velocity = Vector3.new(0, 0, 0)
                        part.RotVelocity = Vector3.new(0, 0, 0)
                    end
                end
                
                -- Disable collision on accessories
                for _, accessory in pairs(character:GetChildren()) do
                    if accessory:IsA("Accessory") then
                        local handle = accessory:FindFirstChild("Handle")
                        if handle and handle:IsA("BasePart") then
                            handle.CanCollide = false
                        end
                    end
                end
            end)
        end)
        
        autoMineConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if not autoMineEnabled then return end
            
            pcall(function()
                local player = game:GetService("Players").LocalPlayer
                local character = player.Character
                if not character then return end
                
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if not humanoidRootPart then return end
                
                -- First try priority rocks
                local targetRock = findClosestRock(priorityRocks)
                
                -- If no priority rocks, try other rocks
                if not targetRock then
                    targetRock = findClosestRock(otherRocks)
                end
                
                if targetRock then
                    -- Get the actual rock model (first Model child)
                    local actualRock = nil
                    for _, child in pairs(targetRock:GetChildren()) do
                        if child:IsA("Model") then
                            -- Check if rock has health attribute and if it's greater than 0
                            local rockHealth = child:GetAttribute("Health")
                            if rockHealth and rockHealth > 0 then
                                actualRock = child
                                break
                            end
                        end
                    end
                    
                    -- If no valid rock found (all destroyed or no health), skip to next one
                    if not actualRock then
                        return
                    end
                    
                    local rockPivot = actualRock:GetPivot()
                    local rockPosition = rockPivot.Position
                    local rockLookVector = rockPivot.LookVector
                    
                    -- Calculate target position with distance and height offset
                    local targetPosition = rockPosition - (rockLookVector * distanceOffset) + Vector3.new(0, heightOffset, 0)
                    
                    local currentPosition = humanoidRootPart.Position
                    local distance = (targetPosition - currentPosition).Magnitude
                    
                    -- Use movement speed from Farming Settings
                    local frameSpeed = movementSpeed / 60
                    
                    -- Check if we're within the distance offset range
                    local distanceToRock = (rockPosition - currentPosition).Magnitude
                    local isAtMiningDistance = math.abs(distanceToRock - math.abs(distanceOffset)) <= 3
                    
                    if distance > 3 then
                        -- Move towards target position
                        local direction = (targetPosition - currentPosition).Unit
                        local newPosition = currentPosition + (direction * frameSpeed)
                        
                        -- Face the rock (not camera)
                        humanoidRootPart.CFrame = CFrame.new(newPosition, rockPosition)
                        
                        -- Clear velocities
                        humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                        humanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
                        humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        humanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    else
                        -- At target position, face rock
                        humanoidRootPart.CFrame = CFrame.new(currentPosition, rockPosition)
                        
                        -- Clear velocities
                        humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                        humanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
                        humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        humanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                        
                        -- Only mine if we're at the correct distance offset from the rock
                        if isAtMiningDistance then
                            pcall(function()
                                local args = {"Pickaxe"}
                                game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated"):InvokeServer(unpack(args))
                            end)
                        end
                    end
                end
            end)
        end)
    end
    
    local function stopAutoMine()
        if autoMineConnection then
            autoMineConnection:Disconnect()
            autoMineConnection = nil
        end
        
        if miningNoclipConnection then
            miningNoclipConnection:Disconnect()
            miningNoclipConnection = nil
        end
        
        -- Re-enable collision
        pcall(function()
            local player = game:GetService("Players").LocalPlayer
            if player.Character then
                for _, part in pairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
        end)
    end
    
    MiningSection:AddToggle({
        Name = "Auto Mine",
        Flag = "Mining_AutoMine",
        Default = false,
        Callback = function(v)
            autoMineEnabled = v
            if v then
                startAutoMine()
            else
                stopAutoMine()
            end
        end
    })

    -- ============================================
    -- ESP Section in MAIN tab
    -- ============================================
    local EspSection = MainTab:DrawSection({ Name = "ESP" })
    
    local selectedRocksForEsp = {}
    local rockEspEnabled = false
    local rockEspConnections = {}
    local rockEspLabels = {}
    
    EspSection:AddDropdown({
        Name = "Select Rocks",
        Flag = "ESP_SelectRocks",
        Default = {},
        Multi = true,
        Values = allRocks,
        Callback = function(selected)
            selectedRocksForEsp = selected
        end
    })
    
    local function createEspLabel(rock)
        -- Create BillboardGui for ESP
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "RockESP"
        billboard.Adornee = rock:FindFirstChild("PrimaryPart") or rock:FindFirstChildWhichIsA("BasePart")
        billboard.Size = UDim2.new(0, 100, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = rock
        
        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        textLabel.TextStrokeTransparency = 0.5
        textLabel.TextScaled = true
        textLabel.Font = Enum.Font.SourceSansBold
        textLabel.Parent = billboard
        
        return billboard, textLabel
    end
    
    local function startRockEsp()
        if rockEspConnections.update then
            rockEspConnections.update:Disconnect()
        end
        
        -- Clear existing ESP labels
        for _, label in pairs(rockEspLabels) do
            if label and label.Parent then
                label:Destroy()
            end
        end
        rockEspLabels = {}
        
        rockEspConnections.update = game:GetService("RunService").Heartbeat:Connect(function()
            if not rockEspEnabled then return end
            
            pcall(function()
                local player = game:GetService("Players").LocalPlayer
                local character = player.Character
                if not character then return end
                
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if not humanoidRootPart then return end
                
                local rocksFolder = workspace:FindFirstChild("Rocks")
                if not rocksFolder then return end
                
                -- Track which rocks are currently valid
                local currentRocks = {}
                
                -- Search through all rock area folders
                local rockAreas = {"Island1CaveDeep", "Island1CaveMid", "Island1CaveStart", "Roof"}
                
                for _, areaName in pairs(rockAreas) do
                    local area = rocksFolder:FindFirstChild(areaName)
                    if area then
                        for _, spawnLocation in pairs(area:GetChildren()) do
                            if spawnLocation:IsA("BasePart") and spawnLocation.Name == "SpawnLocation" then
                                for _, rock in pairs(spawnLocation:GetChildren()) do
                                    if rock:IsA("Model") then
                                        local rockName = rock.Name
                                        local rockHealth = rock:GetAttribute("Health")
                                        
                                        -- Check if this rock is in selected list AND has health > 0
                                        for selectedName, isSelected in pairs(selectedRocksForEsp) do
                                            if isSelected and rockName == selectedName and rockHealth and rockHealth > 0 then
                                                currentRocks[rock] = true
                                                
                                                -- Create or update ESP label
                                                if not rockEspLabels[rock] or not rockEspLabels[rock].Parent then
                                                    local billboard, textLabel = createEspLabel(rock)
                                                    rockEspLabels[rock] = billboard
                                                end
                                                
                                                -- Update distance
                                                local rockPivot = rock:GetPivot()
                                                if rockPivot then
                                                    local distance = (rockPivot.Position - humanoidRootPart.Position).Magnitude
                                                    local textLabel = rockEspLabels[rock]:FindFirstChildWhichIsA("TextLabel")
                                                    if textLabel then
                                                        textLabel.Text = string.format("%s\n%.1f studs", rockName, distance)
                                                    end
                                                end
                                                
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                
                -- Remove ESP labels for rocks that no longer exist or don't have health
                for rock, label in pairs(rockEspLabels) do
                    if not currentRocks[rock] or not rock.Parent then
                        if label and label.Parent then
                            label:Destroy()
                        end
                        rockEspLabels[rock] = nil
                    end
                end
            end)
        end)
    end
    
    local function stopRockEsp()
        if rockEspConnections.update then
            rockEspConnections.update:Disconnect()
            rockEspConnections.update = nil
        end
        
        -- Remove all ESP labels
        for _, label in pairs(rockEspLabels) do
            if label and label.Parent then
                label:Destroy()
            end
        end
        rockEspLabels = {}
    end
    
    EspSection:AddToggle({
        Name = "Rock ESP",
        Flag = "ESP_RockESP",
        Default = false,
        Callback = function(v)
            rockEspEnabled = v
            if v then
                startRockEsp()
            else
                stopRockEsp()
            end
        end
    })
    
    -- Player ESP
    local playerEspEnabled = false
    local playerEspConnections = {}
    local playerEspLabels = {}
    
    local function createPlayerEspLabel(player)
        local character = player.Character
        if not character then return nil, nil end
        
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return nil, nil end
        
        -- Create BillboardGui for ESP
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "PlayerESP"
        billboard.Adornee = humanoidRootPart
        billboard.Size = UDim2.new(0, 100, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = humanoidRootPart
        
        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
        textLabel.TextStrokeTransparency = 0.5
        textLabel.TextScaled = true
        textLabel.Font = Enum.Font.SourceSansBold
        textLabel.Parent = billboard
        
        return billboard, textLabel
    end
    
    local function startPlayerEsp()
        if playerEspConnections.update then
            playerEspConnections.update:Disconnect()
        end
        
        -- Clear existing ESP labels
        for _, label in pairs(playerEspLabels) do
            if label and label.Parent then
                label:Destroy()
            end
        end
        playerEspLabels = {}
        
        playerEspConnections.update = game:GetService("RunService").Heartbeat:Connect(function()
            if not playerEspEnabled then return end
            
            pcall(function()
                local localPlayer = game:GetService("Players").LocalPlayer
                local localCharacter = localPlayer.Character
                if not localCharacter then return end
                
                local localHumanoidRootPart = localCharacter:FindFirstChild("HumanoidRootPart")
                if not localHumanoidRootPart then return end
                
                -- Track which players are currently valid
                local currentPlayers = {}
                
                for _, player in pairs(game:GetService("Players"):GetPlayers()) do
                    if player ~= localPlayer then
                        local character = player.Character
                        if character then
                            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                            local humanoid = character:FindFirstChild("Humanoid")
                            
                            if humanoidRootPart and humanoid and humanoid.Health > 0 then
                                currentPlayers[player] = true
                                
                                -- Create or update ESP label
                                if not playerEspLabels[player] or not playerEspLabels[player].Parent then
                                    local billboard, textLabel = createPlayerEspLabel(player)
                                    if billboard then
                                        playerEspLabels[player] = billboard
                                    end
                                end
                                
                                -- Update distance
                                if playerEspLabels[player] and playerEspLabels[player].Parent then
                                    local distance = (humanoidRootPart.Position - localHumanoidRootPart.Position).Magnitude
                                    local textLabel = playerEspLabels[player]:FindFirstChildWhichIsA("TextLabel")
                                    if textLabel then
                                        textLabel.Text = string.format("%s\n%.1f studs", player.Name, distance)
                                    end
                                end
                            end
                        end
                    end
                end
                
                -- Remove ESP labels for players that left or died
                for player, label in pairs(playerEspLabels) do
                    if not currentPlayers[player] or not player.Parent then
                        if label and label.Parent then
                            label:Destroy()
                        end
                        playerEspLabels[player] = nil
                    end
                end
            end)
        end)
        
        -- Handle new players joining
        playerEspConnections.playerAdded = game:GetService("Players").PlayerAdded:Connect(function(player)
            if not playerEspEnabled then return end
            player.CharacterAdded:Connect(function()
                task.wait(0.5) -- Wait for character to load
            end)
        end)
        
        -- Handle players leaving
        playerEspConnections.playerRemoving = game:GetService("Players").PlayerRemoving:Connect(function(player)
            if playerEspLabels[player] then
                if playerEspLabels[player].Parent then
                    playerEspLabels[player]:Destroy()
                end
                playerEspLabels[player] = nil
            end
        end)
    end
    
    local function stopPlayerEsp()
        if playerEspConnections.update then
            playerEspConnections.update:Disconnect()
            playerEspConnections.update = nil
        end
        
        if playerEspConnections.playerAdded then
            playerEspConnections.playerAdded:Disconnect()
            playerEspConnections.playerAdded = nil
        end
        
        if playerEspConnections.playerRemoving then
            playerEspConnections.playerRemoving:Disconnect()
            playerEspConnections.playerRemoving = nil
        end
        
        -- Remove all ESP labels
        for _, label in pairs(playerEspLabels) do
            if label and label.Parent then
                label:Destroy()
            end
        end
        playerEspLabels = {}
    end
    
    EspSection:AddToggle({
        Name = "Player ESP",
        Flag = "ESP_PlayerESP",
        Default = false,
        Callback = function(v)
            playerEspEnabled = v
            if v then
                startPlayerEsp()
            else
                stopPlayerEsp()
            end
        end
    })
    
    -- NPC ESP
    local npcEspEnabled = false
    local npcEspConnection = nil
    local npcEspLabels = {}
    
    local function createNpcEspLabel(npc)
        -- Create BillboardGui for ESP
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "NpcESP"
        billboard.Adornee = npc:FindFirstChild("HumanoidRootPart") or npc:FindFirstChild("PrimaryPart") or npc:FindFirstChildWhichIsA("BasePart")
        billboard.Size = UDim2.new(0, 100, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = npc
        
        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
        textLabel.TextStrokeTransparency = 0.5
        textLabel.TextScaled = true
        textLabel.Font = Enum.Font.SourceSansBold
        textLabel.Parent = billboard
        
        return billboard, textLabel
    end
    
    local function startNpcEsp()
        if npcEspConnection then
            npcEspConnection:Disconnect()
        end
        
        -- Clear existing ESP labels
        for _, label in pairs(npcEspLabels) do
            if label and label.Parent then
                label:Destroy()
            end
        end
        npcEspLabels = {}
        
        npcEspConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if not npcEspEnabled then return end
            
            pcall(function()
                local player = game:GetService("Players").LocalPlayer
                local character = player.Character
                if not character then return end
                
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if not humanoidRootPart then return end
                
                local proximityFolder = workspace:FindFirstChild("Proximity")
                if not proximityFolder then return end
                
                -- Track which NPCs are currently valid
                local currentNpcs = {}
                
                for _, npc in pairs(proximityFolder:GetChildren()) do
                    if npc:IsA("Model") then
                        local npcPart = npc:FindFirstChild("HumanoidRootPart") or npc:FindFirstChild("PrimaryPart") or npc:FindFirstChildWhichIsA("BasePart")
                        
                        if npcPart then
                            currentNpcs[npc] = true
                            
                            -- Create or update ESP label
                            if not npcEspLabels[npc] or not npcEspLabels[npc].Parent then
                                local billboard, textLabel = createNpcEspLabel(npc)
                                npcEspLabels[npc] = billboard
                            end
                            
                            -- Update distance
                            if npcEspLabels[npc] and npcEspLabels[npc].Parent then
                                local distance = (npcPart.Position - humanoidRootPart.Position).Magnitude
                                local textLabel = npcEspLabels[npc]:FindFirstChildWhichIsA("TextLabel")
                                if textLabel then
                                    textLabel.Text = string.format("%s\n%.1f studs", npc.Name, distance)
                                end
                            end
                        end
                    end
                end
                
                -- Remove ESP labels for NPCs that no longer exist
                for npc, label in pairs(npcEspLabels) do
                    if not currentNpcs[npc] or not npc.Parent then
                        if label and label.Parent then
                            label:Destroy()
                        end
                        npcEspLabels[npc] = nil
                    end
                end
            end)
        end)
    end
    
    local function stopNpcEsp()
        if npcEspConnection then
            npcEspConnection:Disconnect()
            npcEspConnection = nil
        end
        
        -- Remove all ESP labels
        for _, label in pairs(npcEspLabels) do
            if label and label.Parent then
                label:Destroy()
            end
        end
        npcEspLabels = {}
    end
    
    EspSection:AddToggle({
        Name = "NPC ESP",
        Flag = "ESP_NpcESP",
        Default = false,
        Callback = function(v)
            npcEspEnabled = v
            if v then
                startNpcEsp()
            else
                stopNpcEsp()
            end
        end
    })
    
    -- Living Mobs ESP
    local mobEspEnabled = false
    local mobEspConnection = nil
    local mobEspLabels = {}
    
    local function createMobEspLabel(mob)
        -- Create BillboardGui for ESP
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "MobESP"
        billboard.Adornee = mob:FindFirstChild("HumanoidRootPart") or mob:FindFirstChild("PrimaryPart") or mob:FindFirstChildWhichIsA("BasePart")
        billboard.Size = UDim2.new(0, 100, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = mob
        
        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
        textLabel.TextStrokeTransparency = 0.5
        textLabel.TextScaled = true
        textLabel.Font = Enum.Font.SourceSansBold
        textLabel.Parent = billboard
        
        return billboard, textLabel
    end
    
    local function startMobEsp()
        if mobEspConnection then
            mobEspConnection:Disconnect()
        end
        
        -- Clear existing ESP labels
        for _, label in pairs(mobEspLabels) do
            if label and label.Parent then
                label:Destroy()
            end
        end
        mobEspLabels = {}
        
        mobEspConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if not mobEspEnabled then return end
            
            pcall(function()
                local player = game:GetService("Players").LocalPlayer
                local character = player.Character
                if not character then return end
                
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if not humanoidRootPart then return end
                
                local living = workspace:FindFirstChild("Living")
                if not living then return end
                
                -- Track which mobs are currently valid
                local currentMobs = {}
                
                for _, mobModel in pairs(living:GetChildren()) do
                    if mobModel:IsA("Model") and mobModel:GetAttribute("IsNpc") then
                        -- Check if mob is alive
                        local mobHumanoid = mobModel:FindFirstChildOfClass("Humanoid")
                        if mobHumanoid and mobHumanoid.Health > 0 then
                            local mobPart = mobModel:FindFirstChild("HumanoidRootPart") or mobModel:FindFirstChild("PrimaryPart") or mobModel:FindFirstChildWhichIsA("BasePart")
                            
                            if mobPart then
                                currentMobs[mobModel] = true
                                
                                -- Create or update ESP label
                                if not mobEspLabels[mobModel] or not mobEspLabels[mobModel].Parent then
                                    local billboard, textLabel = createMobEspLabel(mobModel)
                                    mobEspLabels[mobModel] = billboard
                                end
                                
                                -- Update distance and display mob name without numbers
                                if mobEspLabels[mobModel] and mobEspLabels[mobModel].Parent then
                                    local distance = (mobPart.Position - humanoidRootPart.Position).Magnitude
                                    local textLabel = mobEspLabels[mobModel]:FindFirstChildWhichIsA("TextLabel")
                                    if textLabel then
                                        -- Strip numbers from end of name (e.g., "Zombie12345" -> "Zombie")
                                        local baseName = mobModel.Name:match("^(.-)%d*$") or mobModel.Name
                                        textLabel.Text = string.format("%s\n%.1f studs", baseName, distance)
                                    end
                                end
                            end
                        end
                    end
                end
                
                -- Remove ESP labels for mobs that died or no longer exist
                for mob, label in pairs(mobEspLabels) do
                    if not currentMobs[mob] or not mob.Parent then
                        if label and label.Parent then
                            label:Destroy()
                        end
                        mobEspLabels[mob] = nil
                    end
                end
            end)
        end)
    end
    
    local function stopMobEsp()
        if mobEspConnection then
            mobEspConnection:Disconnect()
            mobEspConnection = nil
        end
        
        -- Remove all ESP labels
        for _, label in pairs(mobEspLabels) do
            if label and label.Parent then
                label:Destroy()
            end
        end
        mobEspLabels = {}
    end
    
    EspSection:AddToggle({
        Name = "Living Mobs ESP",
        Flag = "ESP_MobESP",
        Default = false,
        Callback = function(v)
            mobEspEnabled = v
            if v then
                startMobEsp()
            else
                stopMobEsp()
            end
        end
    })

    -- ============================================
    -- PICKAXE Section in MAIN tab
    -- ============================================
    local PickaxeSection = MainTab:DrawSection({ Name = "Pickaxe" })
    
    local selectedPickaxe = nil
    local pickaxeBuyNoclipConnection = nil
    
    -- Pickaxe locations (from teleport section)
    local pickaxeLocations = {
        ["Bronze Pickaxe"] = CFrame.new(-80.23, 28.27, 83.95),
        ["Iron Pickaxe"] = CFrame.new(-82.60, 28.56, 85.53),
        ["Gold Pickaxe"] = CFrame.new(-95.75, 28.71, 100.07),
        ["Platinum Pickaxe"] = CFrame.new(-98.66, 28.71, 101.64),
        ["Arcane Pickaxe"] = CFrame.new(234.41, -14.00, -336.50),
        ["Stonewakes Pickaxe"] = CFrame.new(-34.68, -1.08, -267.71)
    }
    
    PickaxeSection:AddDropdown({
        Name = "Buy Pickaxe",
        Flag = "Pickaxe_Select",
        Default = "Bronze Pickaxe",
        Values = {
            "Bronze Pickaxe",
            "Iron Pickaxe",
            "Gold Pickaxe",
            "Platinum Pickaxe",
            "Arcane Pickaxe",
            "Stonewakes Pickaxe"
        },
        Callback = function(value)
            selectedPickaxe = value
        end
    })
    
    local function teleportToPickaxe(targetCFrame)
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character
        if not character then return false end
        
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return false end
        
        local targetPosition = targetCFrame.Position
        local completed = false
        
        -- Enable noclip during movement
        if pickaxeBuyNoclipConnection then pickaxeBuyNoclipConnection:Disconnect() end
        pickaxeBuyNoclipConnection = game:GetService("RunService").Stepped:Connect(function()
            pcall(function()
                if not character then return end
                
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then humanoid.PlatformStand = false end
                
                -- Disable collision on ALL parts
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                        part.Velocity = Vector3.new(0, 0, 0)
                        part.RotVelocity = Vector3.new(0, 0, 0)
                    end
                end
            end)
        end)
        
        -- Move to target
        local startTime = tick()
        while not completed and tick() - startTime < 10 do
            pcall(function()
                if not humanoidRootPart then return end
                
                local currentPosition = humanoidRootPart.Position
                local distance = (targetPosition - currentPosition).Magnitude
                
                if distance < 2 then
                    humanoidRootPart.CFrame = targetCFrame
                    completed = true
                else
                    local direction = (targetPosition - currentPosition).Unit
                    local frameSpeed = 50 / 60  -- 50 studs per second
                    local newPosition = currentPosition + (direction * frameSpeed)
                    humanoidRootPart.CFrame = CFrame.new(newPosition, targetPosition)
                    
                    humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                    humanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
                    humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    humanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end
            end)
            task.wait()
        end
        
        -- Disable noclip
        if pickaxeBuyNoclipConnection then
            pickaxeBuyNoclipConnection:Disconnect()
            pickaxeBuyNoclipConnection = nil
        end
        
        -- Re-enable collision
        pcall(function()
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
        end)
        
        return completed
    end
    
    PickaxeSection:AddButton({
        Name = "Buy Selected Pickaxe",
        Callback = function()
            if not selectedPickaxe or not pickaxeLocations[selectedPickaxe] then
                if Notifier then
                    Notifier.new({ Title = "Error", Content = "Please select a pickaxe first", Duration = 2, Icon = "95448792622941" })
                end
                return
            end
            
            task.spawn(function()
                pcall(function()
                    local player = game:GetService("Players").LocalPlayer
                    local character = player.Character
                    if not character then return end
                    
                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                    if not humanoidRootPart then return end
                    
                    -- Save original position
                    local originalPosition = humanoidRootPart.CFrame
                    
                    -- Pause auto mine and auto kill if running
                    local wasAutoMining = autoMineEnabled
                    local wasAutoKilling = autoKillEnabled
                    
                    if wasAutoMining then
                        autoMineEnabled = false
                        task.wait(0.1)
                    end
                    if wasAutoKilling then
                        autoKillEnabled = false
                        task.wait(0.1)
                    end
                    
                    if Notifier then
                        Notifier.new({ Title = "Buying Pickaxe", Content = "Moving to " .. selectedPickaxe, Duration = 2, Icon = "95448792622941" })
                    end
                    
                    -- Teleport to pickaxe location
                    local success = teleportToPickaxe(pickaxeLocations[selectedPickaxe])
                    
                    if success then
                        task.wait(0.5)
                        
                        -- Purchase the pickaxe using ProximityService
                        local ProximityService = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ProximityService"):WaitForChild("RF")
                        
                        local buySuccess, buyResult = pcall(function()
                            local args = {selectedPickaxe, 1}
                            return ProximityService:WaitForChild("Purchase"):InvokeServer(unpack(args))
                        end)
                        
                        if buySuccess then
                            if Notifier then
                                Notifier.new({ Title = "Success", Content = "Purchased " .. selectedPickaxe, Duration = 3, Icon = "95448792622941" })
                            end
                        else
                            if Notifier then
                                Notifier.new({ Title = "Error", Content = "Failed to purchase (insufficient gold or already owned)", Duration = 3, Icon = "95448792622941" })
                            end
                        end
                        
                        task.wait(0.5)
                    else
                        if Notifier then
                            Notifier.new({ Title = "Error", Content = "Failed to reach pickaxe location", Duration = 2, Icon = "95448792622941" })
                        end
                    end
                    
                    -- Return to original position
                    teleportToPickaxe(originalPosition)
                    task.wait(0.5)
                    
                    -- Resume auto mine and auto kill if they were running
                    if wasAutoMining then
                        autoMineEnabled = true
                    end
                    if wasAutoKilling then
                        autoKillEnabled = true
                    end
                end)
            end)
        end
    })

    -- ============================================
    -- SELL Section in MAIN tab
    -- ============================================
    local SellSection = MainTab:DrawSection({ Name = "Sell" })
    
    local selectedOresToSell = {}
    local sellOresEnabled = false
    local sellOresConnection = nil
    
    -- All ores in the game
    local allOres = {
        -- General
        "Stone", "Sand Stone", "Copper", "Iron", "Tin", "Silver", "Gold", "Platinum",
        "Starite", "Galaxite", "Fichillium", "Fichilliumorite",
        -- Island 1
        "Poopite", "Bananite", "Cardboardite", "Mushroomite", "Aite", "Grass",
        -- Island 2
        "Cobalt", "Titanium", "Lapis Lazuli", "Quartz", "Amethyst", "Topaz",
        "Diamond", "Sapphire", "Cuprite", "Emerald", "Ruby", "Rivalite",
        "Uranium", "Mythril", "Eye Ore", "Lightite", "Volcanic Rock",
        "Obsidian", "Fireite", "Magmaite", "Demonite", "Darkryte",
        "Boneite", "Dark Boneite", "Slimite",
        -- Crystals
        "Crimson Crystal", "Blue Crystal", "Green Crystal", "Orange Crystal",
        "Magenta Crystal", "Arcane Crystal", "Rainbow Crystal"
    }
    
    SellSection:AddDropdown({
        Name = "Select Ores to Sell",
        Flag = "Sell_SelectOres",
        Default = {},
        Multi = true,
        Values = allOres,
        Callback = function(selected)
            selectedOresToSell = selected
        end
    })
    
    local hasInitializedSell = false
    local sellMoveConnection = nil
    local sellNoclipConnection = nil
    local originalSellPosition = nil
    local isSellingNow = false
    
    local function clearDialogueState()
        -- Make sure player is not stuck in dialogue
        pcall(function()
            local DialogueService = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("DialogueService")
            DialogueService:WaitForChild("RE"):WaitForChild("DialogueEvent"):FireServer("Closed")
        end)
        
        -- Reset camera
        pcall(function()
            workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        end)
        
        -- Re-enable collision and movement
        pcall(function()
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.WalkSpeed = 16
                    humanoid.PlatformStand = false
                end
            end
        end)
    end
    
    local function noclipMoveTo(targetCFrame, onArrived)
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character
        if not character then return end
        
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return end
        
        local targetPosition = targetCFrame.Position
        
        -- Clean up existing connections
        if sellMoveConnection then sellMoveConnection:Disconnect() end
        if sellNoclipConnection then sellNoclipConnection:Disconnect() end
        
        -- Enable noclip during movement
        sellNoclipConnection = game:GetService("RunService").Stepped:Connect(function()
            pcall(function()
                local char = player.Character
                if not char then return end
                
                local humanoid = char:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.PlatformStand = false
                end
                
                for _, part in pairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end)
        end)
        
        -- Start moving
        sellMoveConnection = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                local char = player.Character
                if not char then return end
                
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                
                local currentPosition = hrp.Position
                local distance = (targetPosition - currentPosition).Magnitude
                local frameSpeed = 50 / 60
                
                if distance > 2 then
                    local direction = (targetPosition - currentPosition).Unit
                    local newPosition = currentPosition + (direction * frameSpeed)
                    hrp.CFrame = CFrame.new(newPosition, targetPosition)
                    hrp.Velocity = Vector3.new(0, 0, 0)
                    hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                else
                    -- Arrived
                    hrp.CFrame = targetCFrame
                    
                    -- Stop connections
                    if sellMoveConnection then
                        sellMoveConnection:Disconnect()
                        sellMoveConnection = nil
                    end
                    if sellNoclipConnection then
                        sellNoclipConnection:Disconnect()
                        sellNoclipConnection = nil
                    end
                    
                    -- Re-enable collision
                    for _, part in pairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = true
                        end
                    end
                    
                    -- Call callback
                    if onArrived then
                        onArrived()
                    end
                end
            end)
        end)
    end
    
    local function startSellOres()
        sellOresConnection = task.spawn(function()
            while sellOresEnabled do
                pcall(function()
                    if isSellingNow then return end
                    
                    local PlayerController = require(game:GetService("ReplicatedStorage"):WaitForChild("Controllers"):WaitForChild("PlayerController"))
                    local replica = PlayerController.Replica
                    
                    if not replica or not replica.Data or not replica.Data.Inventory then return end
                    
                    -- Build basket of ores to sell
                    local basket = {}
                    local hasOresToSell = false
                    
                    for oreName, isSelected in pairs(selectedOresToSell) do
                        if isSelected then
                            local quantity = replica.Data.Inventory[oreName]
                            if quantity and type(quantity) == "number" and quantity > 0 then
                                basket[oreName] = quantity
                                hasOresToSell = true
                            end
                        end
                    end
                    
                    if hasOresToSell then
                        isSellingNow = true
                        
                        local player = game:GetService("Players").LocalPlayer
                        local character = player.Character
                        if not character then 
                            isSellingNow = false
                            return 
                        end
                        
                        local hrp = character:FindFirstChild("HumanoidRootPart")
                        if not hrp then 
                            isSellingNow = false
                            return 
                        end
                        
                        -- Save original position
                        originalSellPosition = hrp.CFrame
                        
                        print("[Sell Debug] Saving position, moving to Greedy Cey...")
                        
                        -- Move to Greedy Cey
                        local greedyCeyLocation = CFrame.new(-112.75, 37.52, -37.29)
                        noclipMoveTo(greedyCeyLocation, function()
                            task.wait(0.3)
                            
                            -- Sell the ores
                            pcall(function()
                                local greedyCey = workspace:FindFirstChild("Proximity"):FindFirstChild("Greedy Cey")
                                if not greedyCey then 
                                    print("[Sell Debug] Greedy Cey not found!")
                                    return 
                                end
                                
                                print("[Sell Debug] Selling ores...")
                                
                                local ProximityService = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ProximityService"):WaitForChild("RF")
                                ProximityService:WaitForChild("ForceDialogue"):InvokeServer(greedyCey, "SellConfirmMisc")
                                task.wait(0.1)
                                
                                local DialogueService = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("DialogueService")
                                local args = {
                                    "SellConfirm",
                                    {
                                        Basket = basket
                                    }
                                }
                                DialogueService:WaitForChild("RF"):WaitForChild("RunCommand"):InvokeServer(unpack(args))
                                
                                print("[Sell Debug] Sold! Clearing dialogue...")
                                
                                -- Clear dialogue state immediately
                                clearDialogueState()
                                
                                if Notifier then
                                    local totalOres = 0
                                    for _, qty in pairs(basket) do
                                        totalOres = totalOres + qty
                                    end
                                    Notifier.new({ Title = "Ores Sold", Content = string.format("Sold %d ores", totalOres), Duration = 2, Icon = "95448792622941" })
                                end
                            end)
                            
                            task.wait(0.2)
                            
                            -- Clear dialogue again before returning
                            clearDialogueState()
                            
                            print("[Sell Debug] Returning to original position...")
                            
                            -- Return to original position
                            if originalSellPosition then
                                noclipMoveTo(originalSellPosition, function()
                                    -- Clear dialogue one more time after arriving
                                    clearDialogueState()
                                    print("[Sell Debug] Returned!")
                                    isSellingNow = false
                                end)
                            else
                                isSellingNow = false
                            end
                        end)
                    end
                end)
                
                -- Wait before checking again
                task.wait(3)
            end
            print("[Sell Debug] Loop ended")
        end)
    end
    
    local function stopSellOres()
        -- Stop movement connections
        if sellMoveConnection then
            sellMoveConnection:Disconnect()
            sellMoveConnection = nil
        end
        if sellNoclipConnection then
            sellNoclipConnection:Disconnect()
            sellNoclipConnection = nil
        end
        
        -- Clear dialogue state and restore movement
        clearDialogueState()
        
        isSellingNow = false
    end
    
    SellSection:AddToggle({
        Name = "Sell Ores",
        Flag = "Sell_SellOres",
        Default = false,
        Callback = function(v)
            sellOresEnabled = v
            if v then
                startSellOres()
            else
                stopSellOres()
            end
        end
    })

    -- ============================================
    -- ENHANCE Section in MAIN tab
    -- ============================================
    local EnhanceSection = MainTab:DrawSection({ Name = "Enhance" })
    
    local selectedEquipment = nil
    local equipmentList = {}
    local stopAtLevel = 1
    local guaranteedOnly = false
    local autoEnhanceEnabled = false
    local autoEnhanceConnection = nil
    local equipmentDropdown = nil
    
    local function updateEquipmentDropdown()
        equipmentList = {}
        local dropdownValues = {"None"}
        
        pcall(function()
            local PlayerController = require(game:GetService("ReplicatedStorage"):WaitForChild("Controllers"):WaitForChild("PlayerController"))
            local replica = PlayerController.Replica
            
            if not replica or not replica.Data or not replica.Data.Inventory then return end
            
            -- Get fresh equipment data with current enhancement levels and quality
            for _, equipment in pairs(replica.Data.Inventory.Equipments) do
                if equipment.GUID and equipment.Type then
                    local upgradeLevel = equipment.Upgrade or 0
                    local quality = equipment.Quality or 0
                    local displayName = string.format("%s (+%d) [%d%%]", equipment.Type, upgradeLevel, math.floor(quality))
                    
                    table.insert(equipmentList, {
                        GUID = equipment.GUID,
                        Type = equipment.Type,
                        Upgrade = upgradeLevel,
                        Quality = quality,
                        displayName = displayName,
                        fullData = equipment
                    })
                    
                    table.insert(dropdownValues, displayName)
                end
            end
        end)
        
        -- Update selected equipment if it still exists
        if selectedEquipment then
            local updatedEquipment = nil
            for _, equipment in pairs(equipmentList) do
                if equipment.GUID == selectedEquipment.GUID then
                    updatedEquipment = equipment
                    selectedEquipment = equipment
                    break
                end
            end
            
            if not updatedEquipment then
                selectedEquipment = nil
            end
        end
        
        -- Recreate dropdown with fresh enhancement levels and quality percentages
        if equipmentDropdown then
            pcall(function() equipmentDropdown:Destroy() end)
        end
        
        equipmentDropdown = EnhanceSection:AddDropdown({
            Name = "Select Equipment",
            Flag = "Enhance_SelectEquipment",
            Default = selectedEquipment and selectedEquipment.displayName or "None",
            Values = dropdownValues,
            Callback = function(value)
                if value == "None" then
                    selectedEquipment = nil
                else
                    for _, equipment in pairs(equipmentList) do
                        if equipment.displayName == value then
                            selectedEquipment = equipment
                            break
                        end
                    end
                end
            end
        })
        
        if Notifier then
            Notifier.new({ Title = "Equipment List", Content = "Found " .. #equipmentList .. " equipment items with current stats", Duration = 2, Icon = "95448792622941" })
        end
    end
    
    -- Initial dropdown
    updateEquipmentDropdown()
    
    EnhanceSection:AddButton({
        Name = "Refresh Item List",
        Callback = function()
            updateEquipmentDropdown()
        end
    })
    
    EnhanceSection:AddSlider({
        Name = "Stop at Level",
        Min = 1,
        Max = 9,
        Default = 1,
        Round = 0,
        Flag = "Enhance_StopAtLevel",
        Callback = function(value)
            stopAtLevel = value
        end
    })
    
    EnhanceSection:AddToggle({
        Name = "Enhance Guaranteed Only",
        Flag = "Enhance_GuaranteedOnly",
        Default = false,
        Callback = function(v)
            guaranteedOnly = v
        end
    })
    
    local function startAutoEnhance()
        if autoEnhanceConnection then autoEnhanceConnection:Disconnect() end
        
        autoEnhanceConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if not autoEnhanceEnabled then return end
            
            pcall(function()
                if not selectedEquipment then return end
                
                -- Refresh equipment data
                local PlayerController = require(game:GetService("ReplicatedStorage"):WaitForChild("Controllers"):WaitForChild("PlayerController"))
                local replica = PlayerController.Replica
                
                if not replica or not replica.Data or not replica.Data.Inventory then return end
                
                -- Find current equipment data
                local currentEquipment = nil
                for _, equipment in pairs(replica.Data.Inventory.Equipments) do
                    if equipment.GUID == selectedEquipment.GUID then
                        currentEquipment = equipment
                        break
                    end
                end
                
                if not currentEquipment then return end
                
                local currentUpgrade = currentEquipment.Upgrade or 0
                
                -- Check if reached target level
                if currentUpgrade >= stopAtLevel then
                    return
                end
                
                -- Check if at max level
                if currentUpgrade >= 9 then
                    return
                end
                
                -- If guaranteed only is enabled, check success chance
                if guaranteedOnly then
                    local EnhanceService = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("EnhanceService"):WaitForChild("RF")
                    
                    local success, successChance = pcall(function()
                        return EnhanceService:WaitForChild("CalculateSuccessChance"):InvokeServer(currentEquipment)
                    end)
                    
                    if success and successChance then
                        -- Only enhance if 100% success chance
                        if successChance < 100 then
                            return
                        end
                    else
                        return
                    end
                end
                
                -- Enhance the equipment
                local EnhanceService = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("EnhanceService"):WaitForChild("RF")
                
                pcall(function()
                    local args = {selectedEquipment.GUID}
                    EnhanceService:WaitForChild("EnhanceEquipment"):InvokeServer(unpack(args))
                end)
                
                -- Wait a bit before next enhancement
                task.wait(0.5)
            end)
        end)
    end
    
    local function stopAutoEnhance()
        if autoEnhanceConnection then
            autoEnhanceConnection:Disconnect()
            autoEnhanceConnection = nil
        end
    end
    
    EnhanceSection:AddToggle({
        Name = "Enable Auto Enhance",
        Flag = "Enhance_AutoEnhance",
        Default = false,
        Callback = function(v)
            autoEnhanceEnabled = v
            if v then
                if not selectedEquipment then
                    if Notifier then
                        Notifier.new({ Title = "Error", Content = "Please select equipment first", Duration = 2, Icon = "95448792622941" })
                    end
                    autoEnhanceEnabled = false
                    return
                end
                startAutoEnhance()
            else
                stopAutoEnhance()
            end
        end
    })

    -- ============================================
    -- RACE Section in MAIN tab
    -- ============================================
    local RaceSection = MainTab:DrawSection({ Name = "Race" })
    
    local selectedRace = nil
    local autoRollEnabled = false
    local autoRollConnection = nil
    local spinsText = nil
    
    -- All available races
    local allRaces = {
        "Human",
        "Elf",
        "Zombie",
        "Goblin",
        "Undead",
        "Orc",
        "Dwarf",
        "Shadow",
        "Minotaur",
        "Dragonborn",
        "Golem",
        "Angel",
        "Demon"
    }
    
    RaceSection:AddDropdown({
        Name = "Select Race",
        Flag = "Race_SelectRace",
        Default = "Human",
        Values = allRaces,
        Callback = function(value)
            selectedRace = value
        end
    })
    
    -- Create a button to show spins (will update text dynamically)
    local spinsButton = RaceSection:AddButton({
        Name = "Spins Left: Loading...",
        Callback = function()
            -- Just display, no action needed
        end
    })
    
    local function updateSpinsText()
        pcall(function()
            local PlayerController = require(game:GetService("ReplicatedStorage"):WaitForChild("Controllers"):WaitForChild("PlayerController"))
            local replica = PlayerController.Replica
            
            if replica and replica.Data and replica.Data.Spins then
                local spinsCount = tostring(replica.Data.Spins)
                -- Update button text by changing the Name property
                if spinsButton and spinsButton.Name then
                    spinsButton.Name = "Spins Left: " .. spinsCount
                end
            end
        end)
    end
    
    -- Initial update
    task.delay(1, updateSpinsText)
    
    local function startAutoRoll()
        if autoRollConnection then autoRollConnection:Disconnect() end
        
        autoRollConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if not autoRollEnabled then return end
            
            pcall(function()
                local PlayerController = require(game:GetService("ReplicatedStorage"):WaitForChild("Controllers"):WaitForChild("PlayerController"))
                local replica = PlayerController.Replica
                
                if not replica or not replica.Data then return end
                
                -- Update spins display
                updateSpinsText()
                
                -- Check current race
                local currentRace = replica.Data.Race or "Human"
                
                -- If we got the desired race, stop auto rolling
                if currentRace == selectedRace then
                    autoRollEnabled = false
                    if Notifier then
                        Notifier.new({ Title = "Race Obtained!", Content = "Got " .. selectedRace .. " race!", Duration = 3, Icon = "95448792622941" })
                    end
                    return
                end
                
                -- Check if we have spins left
                local spins = replica.Data.Spins or 0
                if spins <= 0 then
                    autoRollEnabled = false
                    if Notifier then
                        Notifier.new({ Title = "No Spins", Content = "Out of spins!", Duration = 2, Icon = "95448792622941" })
                    end
                    return
                end
                
                -- Reroll for the race
                local RaceService = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("RaceService"):WaitForChild("RF")
                
                pcall(function()
                    RaceService:WaitForChild("Reroll"):InvokeServer()
                end)
                
                -- Wait 3 seconds before next roll (gives time for roll animation)
                task.wait(3)
            end)
        end)
    end
    
    local function stopAutoRoll()
        if autoRollConnection then
            autoRollConnection:Disconnect()
            autoRollConnection = nil
        end
    end
    
    RaceSection:AddToggle({
        Name = "Auto Roll Race",
        Flag = "Race_AutoRoll",
        Default = false,
        Callback = function(v)
            autoRollEnabled = v
            if v then
                if not selectedRace then
                    if Notifier then
                        Notifier.new({ Title = "Error", Content = "Please select a race first", Duration = 2, Icon = "95448792622941" })
                    end
                    autoRollEnabled = false
                    return
                end
                startAutoRoll()
            else
                stopAutoRoll()
            end
        end
    })

    -- ============================================
    -- POTIONS Section in MAIN tab
    -- ============================================
    local PotionsSection = MainTab:DrawSection({ Name = "Potions" })
    
    local selectedPotionsToBuy = {}
    local selectedPotionsToUse = {}
    local potionQuantity = 1
    local autoBuyEnabled = false
    local autoUseEnabled = false
    local autoBuyConnection = nil
    local autoUseConnection = nil
    local potionBuyNoclipConnection = nil
    
    -- All available potions in the game
    local allPotions = {
        "HealthPotion1",
        "HealthPotion2",
        "MinerPotion1",
        "AttackDamagePotion1",
        "MovementSpeedPotion1",
        "LuckPotion1"
    }
    
    -- Potion NPC locations (from teleport section)
    local potionNpcLocations = {
        ["HealthPotion1"] = CFrame.new(-147.42, 27.48, 111.64),  -- Health Potion 1
        ["HealthPotion2"] = CFrame.new(-147.42, 27.48, 111.64),  -- Health Potion 1 (same NPC)
        ["MinerPotion1"] = CFrame.new(-159.94, 27.73, 118.73),   -- Miner Potion 1
        ["AttackDamagePotion1"] = CFrame.new(-145.43, 27.06, 110.88),  -- AttackDamagePotion1
        ["MovementSpeedPotion1"] = CFrame.new(-149.44, 27.61, 112.44), -- SpeedPotion1
        ["LuckPotion1"] = CFrame.new(-162.46, 27.50, 120.60)     -- Lucky Potion 1
    }
    
    PotionsSection:AddDropdown({
        Name = "Select Potion to Buy",
        Flag = "Potions_SelectToBuy",
        Default = {},
        Multi = true,
        Values = allPotions,
        Callback = function(selected)
            selectedPotionsToBuy = selected
        end
    })
    
    PotionsSection:AddSlider({
        Name = "Quantity",
        Min = 1,
        Max = 50,
        Default = 1,
        Round = 0,
        Flag = "Potions_Quantity",
        Callback = function(value)
            potionQuantity = value
        end
    })
    
    local function teleportToLocation(targetCFrame)
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character
        if not character then return false end
        
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return false end
        
        local startPosition = humanoidRootPart.Position
        local targetPosition = targetCFrame.Position
        local completed = false
        
        -- Enable noclip during movement
        if potionBuyNoclipConnection then potionBuyNoclipConnection:Disconnect() end
        potionBuyNoclipConnection = game:GetService("RunService").Stepped:Connect(function()
            pcall(function()
                if not character then return end
                
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then humanoid.PlatformStand = false end
                
                -- Disable collision on ALL parts
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                        part.Velocity = Vector3.new(0, 0, 0)
                        part.RotVelocity = Vector3.new(0, 0, 0)
                    end
                end
            end)
        end)
        
        -- Move to target
        local startTime = tick()
        while not completed and tick() - startTime < 10 do
            pcall(function()
                if not humanoidRootPart then return end
                
                local currentPosition = humanoidRootPart.Position
                local distance = (targetPosition - currentPosition).Magnitude
                
                if distance < 2 then
                    humanoidRootPart.CFrame = targetCFrame
                    completed = true
                else
                    local direction = (targetPosition - currentPosition).Unit
                    local frameSpeed = 50 / 60  -- 50 studs per second
                    local newPosition = currentPosition + (direction * frameSpeed)
                    humanoidRootPart.CFrame = CFrame.new(newPosition, targetPosition)
                    
                    humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                    humanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
                    humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    humanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end
            end)
            task.wait()
        end
        
        -- Disable noclip
        if potionBuyNoclipConnection then
            potionBuyNoclipConnection:Disconnect()
            potionBuyNoclipConnection = nil
        end
        
        -- Re-enable collision
        pcall(function()
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
        end)
        
        return completed
    end
    
    local function startAutoBuy()
        autoBuyConnection = true
        task.spawn(function()
            while autoBuyConnection and autoBuyEnabled do
                task.wait(5) -- Check every 5 seconds
                
                if not autoBuyEnabled then 
                    break 
                end
                
                pcall(function()
                    local player = game:GetService("Players").LocalPlayer
                    local character = player.Character
                    if not character then return end
                    
                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                    if not humanoidRootPart then return end
                    
                    local PlayerController = require(game:GetService("ReplicatedStorage"):WaitForChild("Controllers"):WaitForChild("PlayerController"))
                    local replica = PlayerController.Replica
                    
                    if not replica or not replica.Data or not replica.Data.Inventory then return end
                    
                    -- Check if we need to buy any potions
                    local needsToBuy = false
                    for potionName, isSelected in pairs(selectedPotionsToBuy) do
                        if isSelected then
                            local currentCount = 0
                            -- Check Misc array for potions
                            if replica.Data.Inventory.Misc and type(replica.Data.Inventory.Misc) == "table" then
                                for _, item in pairs(replica.Data.Inventory.Misc) do
                                    if type(item) == "table" and item.Name == potionName then
                                        currentCount = item.Quantity or 0
                                        break
                                    end
                                end
                            end
                            
                            if currentCount < potionQuantity then
                                needsToBuy = true
                                break
                            end
                        end
                    end
                    
                    -- Only proceed if we actually need to buy potions
                    if not needsToBuy then
                        return
                    end
                    
                    -- Save original position
                    local originalPosition = humanoidRootPart.CFrame
                    
                    -- Pause auto mine and auto kill if running
                    local wasAutoMining = autoMineEnabled
                    local wasAutoKilling = autoKillEnabled
                    
                    if wasAutoMining then
                        autoMineEnabled = false
                        task.wait(0.1)
                    end
                    if wasAutoKilling then
                        autoKillEnabled = false
                        task.wait(0.1)
                    end
                    
                    local stashFull = false
                    local ProximityService = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ProximityService"):WaitForChild("RF")
                    
                    -- Check each selected potion
                    for potionName, isSelected in pairs(selectedPotionsToBuy) do
                        if not autoBuyEnabled then 
                            break 
                        end
                        
                        if stashFull then
                            break
                        end
                        
                        if isSelected and potionNpcLocations[potionName] then
                            -- Teleport to potion NPC once
                            local success = teleportToLocation(potionNpcLocations[potionName])
                            
                            if success then
                                task.wait(0.5)
                                
                                -- Keep buying until we reach target quantity or stash full
                                while autoBuyEnabled and not stashFull do
                                    -- Get current count from Misc array
                                    local currentCount = 0
                                    local freshReplica = PlayerController.Replica
                                    if freshReplica and freshReplica.Data.Inventory.Misc and type(freshReplica.Data.Inventory.Misc) == "table" then
                                        for _, item in pairs(freshReplica.Data.Inventory.Misc) do
                                            if type(item) == "table" and item.Name == potionName then
                                                currentCount = item.Quantity or 0
                                                break
                                            end
                                        end
                                    end
                                    
                                    -- Check if we've reached target quantity
                                    if currentCount >= potionQuantity then
                                        break
                                    end
                                    
                                    -- Buy one more
                                    local buySuccess, buyResult = pcall(function()
                                        local args = {potionName, 1}
                                        return ProximityService:WaitForChild("Purchase"):InvokeServer(unpack(args))
                                    end)
                                    
                                    -- Check if we got stash full error
                                    if not buySuccess or (buyResult == false) then
                                        stashFull = true
                                        if Notifier then
                                            Notifier.new({ Title = "Auto Buy Stopped", Content = "Stash full or potion limit reached", Duration = 3, Icon = "95448792622941" })
                                        end
                                        break
                                    end
                                    
                                    task.wait(0.5) -- Wait between purchases
                                end
                            end
                        end
                    end
                    
                    -- Return to original position
                    teleportToLocation(originalPosition)
                    task.wait(0.5)
                    
                    -- Resume auto mine and auto kill if they were running
                    if wasAutoMining then
                        autoMineEnabled = true
                    end
                    if wasAutoKilling then
                        autoKillEnabled = true
                    end
                end)
            end
        end)
    end
    
    local function stopAutoBuy()
        autoBuyConnection = false
        if potionBuyNoclipConnection then
            potionBuyNoclipConnection:Disconnect()
            potionBuyNoclipConnection = nil
        end
    end
    
    PotionsSection:AddToggle({
        Name = "Auto Buy Selected Potions",
        Flag = "Potions_AutoBuy",
        Default = false,
        Callback = function(v)
            autoBuyEnabled = v
            if v then
                startAutoBuy()
            else
                stopAutoBuy()
            end
        end
    })
    
    PotionsSection:AddDropdown({
        Name = "Use Potion",
        Flag = "Potions_SelectToUse",
        Default = {},
        Multi = true,
        Values = allPotions,
        Callback = function(selected)
            selectedPotionsToUse = selected
        end
    })
    
    local potionCooldowns = {}
    
    local function startAutoUse()
        if autoUseConnection then
            autoUseConnection:Disconnect()
            autoUseConnection = nil
        end
        
        -- Cache the remote path once like the working example
        local Remote = game:GetService("ReplicatedStorage")
            :WaitForChild("Shared")
            :WaitForChild("Packages")
            :WaitForChild("Knit")
            :WaitForChild("Services")
            :WaitForChild("ToolService")
            :WaitForChild("RF")
            :WaitForChild("ToolActivated")
        
        -- Set connection flag
        autoUseConnection = true
        
        -- Clean loop instead of Heartbeat with task.wait()
        task.spawn(function()
            while autoUseConnection and autoUseEnabled do
                task.wait(2.5) -- Stable timing
                
                pcall(function()
                    -- Protected require
                    local success, PlayerController = pcall(function()
                        return require(game:GetService("ReplicatedStorage"):WaitForChild("Controllers"):WaitForChild("PlayerController"))
                    end)
                    
                    if not success or not PlayerController then 
                        return 
                    end
                    
                    local replica = PlayerController.Replica
                    if not replica or not replica.Data or not replica.Data.Inventory then 
                        return 
                    end
                    
                    local currentTime = tick()
                    
                    -- Loop through each selected potion
                    for potionName, isSelected in pairs(selectedPotionsToUse) do
                        if isSelected then
                            -- Per-potion cooldown (3 seconds)
                            if potionCooldowns[potionName] and currentTime - potionCooldowns[potionName] < 3 then
                                continue
                            end
                            
                            -- Check if we have this potion as an item
                            -- Potions are stored in replica.Data.Inventory.Misc as an array
                            local potionCount = 0
                            local inventory = replica.Data.Inventory
                            
                            -- Check Misc array for the potion
                            if inventory.Misc and type(inventory.Misc) == "table" then
                                for _, item in pairs(inventory.Misc) do
                                    if type(item) == "table" and item.Name == potionName then
                                        potionCount = item.Quantity or 0
                                        break
                                    end
                                end
                            end
                            
                            -- If we have the potion, use it
                            if potionCount > 0 then
                                local args = {potionName}
                                pcall(function()
                                    Remote:InvokeServer(unpack(args))
                                end)
                                
                                -- Update cooldown
                                potionCooldowns[potionName] = currentTime
                                task.wait(0.3) -- Small delay between different potions
                            end
                        end
                    end
                end)
            end
        end)
    end
    
    local function stopAutoUse()
        autoUseConnection = false
        potionCooldowns = {}
    end
    
    PotionsSection:AddToggle({
        Name = "Auto Use Potions",
        Flag = "Potions_AutoUse",
        Default = false,
        Callback = function(v)
            autoUseEnabled = v
            if v then
                startAutoUse()
            else
                stopAutoUse()
            end
        end
    })

    -- ============================================
    -- INDEX Section in MAIN tab (Auto Claim Codex)
    -- ============================================
    local IndexSection = MainTab:DrawSection({ Name = "Index" })
    
    local autoClaimIndexEnabled = false
    local autoClaimConnection = nil
    
    local function startAutoClaimIndex()
        if autoClaimConnection then autoClaimConnection:Disconnect() end
        
        autoClaimConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if not autoClaimIndexEnabled then return end
            
            pcall(function()
                local Players = game:GetService("Players")
                local LocalPlayer = Players.LocalPlayer
                
                if not LocalPlayer then return end
                
                -- Get player's replica data (this is how the codex tracks discovered/claimed items)
                local PlayerController = require(game:GetService("ReplicatedStorage"):WaitForChild("Controllers"):WaitForChild("PlayerController"))
                local replica = PlayerController.Replica
                
                if not replica or not replica.Data or not replica.Data.Codex then return end
                
                local codex = replica.Data.Codex
                local CodexService = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("CodexService"):WaitForChild("RF")
                
                -- Check and claim Ores
                if codex.Ores then
                    for oreName, oreData in pairs(codex.Ores) do
                        if oreData and not oreData.IsClaimed then
                            -- Claim this ore
                            local success = pcall(function()
                                local args = {oreName}
                                CodexService:WaitForChild("ClaimOre"):InvokeServer(unpack(args))
                            end)
                            
                            if success and Notifier then
                                Notifier.new({ Title = "Index Claimed", Content = "Claimed ore: " .. oreName, Duration = 2, Icon = "95448792622941" })
                            end
                            
                            task.wait(0.5) -- Small delay between claims
                        end
                    end
                end
                
                -- Check and claim Equipments
                if codex.Equipments then
                    for equipmentName, equipmentData in pairs(codex.Equipments) do
                        if equipmentData and not equipmentData.IsClaimed then
                            -- Claim this equipment
                            local success = pcall(function()
                                local args = {equipmentName}
                                CodexService:WaitForChild("ClaimEquipment"):InvokeServer(unpack(args))
                            end)
                            
                            if success and Notifier then
                                Notifier.new({ Title = "Index Claimed", Content = "Claimed equipment: " .. equipmentName, Duration = 2, Icon = "95448792622941" })
                            end
                            
                            task.wait(0.5) -- Small delay between claims
                        end
                    end
                end
                
                -- Check and claim Enemies
                if codex.Enemies then
                    for enemyName, enemyData in pairs(codex.Enemies) do
                        if enemyData and not enemyData.IsClaimed then
                            -- Claim this enemy
                            local success = pcall(function()
                                local args = {enemyName}
                                CodexService:WaitForChild("ClaimEnemy"):InvokeServer(unpack(args))
                            end)
                            
                            if success and Notifier then
                                Notifier.new({ Title = "Index Claimed", Content = "Claimed enemy: " .. enemyName, Duration = 2, Icon = "95448792622941" })
                            end
                            
                            task.wait(0.5) -- Small delay between claims
                        end
                    end
                end
            end)
            
            -- Only check every 2 seconds to avoid spam
            task.wait(2)
        end)
    end
    
    local function stopAutoClaimIndex()
        if autoClaimConnection then
            autoClaimConnection:Disconnect()
            autoClaimConnection = nil
        end
    end
    
    IndexSection:AddToggle({
        Name = "Auto Claim Index",
        Flag = "Index_AutoClaim",
        Default = false,
        Callback = function(v)
            autoClaimIndexEnabled = v
            if v then
                startAutoClaimIndex()
            else
                stopAutoClaimIndex()
            end
        end
    })

    -- ============================================
    -- FORGE Section in MAIN tab (Auto Minigames like Pump)
    -- ============================================
    do
        local ForgeSection = MainTab:DrawSection({ Name = "Forge Tools" })
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local PlayerGui = LocalPlayer and LocalPlayer:WaitForChild("PlayerGui")
        local RunService = game:GetService("RunService")
        
        local autoPumpEnabled = false
        local pumpConnection = nil

        stopAutoPump = function()
            autoPumpEnabled = false
            if pumpConnection then
                pumpConnection:Disconnect()
                pumpConnection = nil
            end
        end

        local pumpConnection = nil
        local pumpHooked = false
        
        local function startAutoPump()
            if pumpConnection then pumpConnection:Disconnect() end
            
            if not pumpHooked then
                pumpHooked = true
                task.spawn(function()
                    repeat task.wait() until LocalPlayer.Character
                    
                    local Controllers = game:GetService("ReplicatedStorage"):WaitForChild("Controllers")
                    local ForgeCtrl = require(Controllers:WaitForChild("ForgeController"))
                    
                    repeat task.wait(0.1) until ForgeCtrl and ForgeCtrl.Minigames
                    
                    if ForgeCtrl.Minigames.MeltMinigame then
                        local orig = ForgeCtrl.Minigames.MeltMinigame.Start
                        ForgeCtrl.Minigames.MeltMinigame.Start = function(s, d)
                            if not autoPumpEnabled then return orig(s, d) end
                            
                            local v1 = workspace:GetServerTimeNow() - d.StartTime
                            local startWait = workspace:GetServerTimeNow()
                            task.wait(d.RequiredTime)
                            local totalWait = workspace:GetServerTimeNow() - startWait
                            return workspace:GetServerTimeNow() - v1 - totalWait
                        end
                    end
                end)
            end
              
            pumpConnection = RunService.Heartbeat:Connect(function() end)
        end
        
        local function stopAutoPump()
            if pumpConnection then
                pumpConnection:Disconnect()
                pumpConnection = nil
            end
        end

        ForgeSection:AddToggle({
            Name = "Auto Pump",
            Flag = "Forge_AutoPump",
            Default = false,
            Callback = function(v)
                autoPumpEnabled = v
                if v then
                    startAutoPump()
                else
                    stopAutoPump()
                end
            end
        })

        local autoPourEnabled = false
        local pourConnection = nil
        local pourHooked = false
        
        local function startAutoPour()
            if pourConnection then pourConnection:Disconnect() end
            
            if not pourHooked then
                pourHooked = true
                task.spawn(function()
                    local Controllers = game:GetService("ReplicatedStorage"):WaitForChild("Controllers")
                    local ForgeCtrl = require(Controllers:WaitForChild("ForgeController"))
                    
                    repeat task.wait(0.1) until ForgeCtrl and ForgeCtrl.Minigames
                    
                    if ForgeCtrl.Minigames.PourMinigame then
                        local orig = ForgeCtrl.Minigames.PourMinigame.Start
                        ForgeCtrl.Minigames.PourMinigame.Start = function(s, d)
                            if not autoPourEnabled then return orig(s, d) end
                            
                            local v1 = workspace:GetServerTimeNow() - d.StartTime
                            local startWait = workspace:GetServerTimeNow()
                            task.wait(d.RequiredTime)
                            local totalWait = workspace:GetServerTimeNow() - startWait
                            return workspace:GetServerTimeNow() - v1 - totalWait
                        end
                    end
                end)
            end
            
            pourConnection = RunService.Heartbeat:Connect(function() end)
        end
        
        local function stopAutoPour()
            if pourConnection then
                pourConnection:Disconnect()
                pourConnection = nil
            end
        end

        ForgeSection:AddToggle({
            Name = "Auto Pour",
            Flag = "Forge_AutoPour",
            Default = false,
            Callback = function(v)
                autoPourEnabled = v
                if v then
                    startAutoPour()
                else
                    stopAutoPour()
                end
            end
        })

        -- Auto Hammer Toggle
        local autoHammerEnabled = false
        local hammerConnection = nil

        local stopAutoHammer = function()
            autoHammerEnabled = false
            if hammerConnection then
                hammerConnection:Disconnect()
                hammerConnection = nil
            end
        end

        local function startAutoHammer()
            if hammerConnection then
                hammerConnection:Disconnect()
            end
            
            local trackedNotes = {}
            local hammerHooked = false
            local childAddedConnection = nil
            
            -- Hook the HammerMinigame module AND ChildAdded for instant frame detection
            if not hammerHooked then
                hammerHooked = true
                task.spawn(function()
                    local ReplicatedStorage = game:GetService("ReplicatedStorage")
                    local HammerMinigameModule = ReplicatedStorage:WaitForChild("Controllers"):WaitForChild("ForgeController"):FindFirstChild("HammerMinigame")
                    
                    if HammerMinigameModule then
                        local originalModule = require(HammerMinigameModule)
                        local originalCreateNote = originalModule.CreateNote
                        
                        -- Pending note queue - stores timing data before frame appears
                        local pendingNotes = {}
                        
                        -- Setup ChildAdded listener on HammerMinigame GUI
                        local forgeGui = game.Players.LocalPlayer.PlayerGui:WaitForChild("Forge")
                        local hammerMinigame = forgeGui:WaitForChild("HammerMinigame")
                        
                        childAddedConnection = hammerMinigame.ChildAdded:Connect(function(child)
                            if not autoHammerEnabled then return end
                            
                            -- Check if this is a note frame
                            task.defer(function()
                                local frame = child:FindFirstChild("Frame")
                                if not frame then return end
                                
                                local hasCircle = frame:FindFirstChild("Circle")
                                local hasBorder = frame:FindFirstChild("Border")
                                
                                if hasCircle and hasBorder then
                                    -- Find matching pending note (oldest one)
                                    local noteData = table.remove(pendingNotes, 1)
                                    
                                    if noteData and not noteData.clicked then
                                        noteData.frame = child
                                        trackedNotes[child] = noteData
                                        
                                        -- Calculate exact delay until perfect moment
                                        local now = workspace:GetServerTimeNow()
                                        local delayTime = noteData.target - now
                                        
                                        if delayTime > 0 then
                                            -- Schedule click at EXACT perfect moment using task.delay
                                            task.delay(delayTime, function()
                                                if noteData.clicked or not autoHammerEnabled then return end
                                                
                                                noteData.clicked = true
                                                local clickTime = workspace:GetServerTimeNow()
                                                local diff = clickTime - noteData.target
                                                
                                                -- Fire click
                                                pcall(function()
                                                    for _, conn in pairs(getconnections(child.MouseButton1Click)) do
                                                        conn:Fire()
                                                    end
                                                end)
                                                
                                                trackedNotes[child] = nil
                                            end)
                                        else
                                            -- Already past target, click immediately
                                            noteData.clicked = true
                                            
                                            pcall(function()
                                                for _, conn in pairs(getconnections(child.MouseButton1Click)) do
                                                    conn:Fire()
                                                end
                                            end)
                                            
                                            trackedNotes[child] = nil
                                        end
                                    end
                                end
                            end)
                        end)
                        
                        -- Hook CreateNote to capture timing data BEFORE frame is created
                        originalModule.CreateNote = function(self, arg2, arg3, arg4)
                            if not autoHammerEnabled then
                                return originalCreateNote(self, arg2, arg3, arg4)
                            end

                            local lifetime = arg2.Lifetime
                            local spawnServerTime = workspace:GetServerTimeNow()
                            local targetTime = spawnServerTime + lifetime * 25 / 44
                            local timingIntervals = arg2.TimingIntervals or {}
                            local perfectInterval = nil

                            for _, interval in ipairs(timingIntervals) do
                                if interval.Interval and (not perfectInterval or interval.Interval < perfectInterval) then
                                    perfectInterval = interval.Interval
                                end
                            end

                            perfectInterval = perfectInterval or 0.05

                            -- Queue the timing data
                            local noteData = {
                                target = targetTime,
                                intervals = timingIntervals,
                                perfectInterval = perfectInterval,
                                lifetime = lifetime,
                                frame = nil,
                                clicked = false,
                            }
                            
                            table.insert(pendingNotes, noteData)
                            
                            -- Cleanup old pending notes after lifetime
                            task.delay(lifetime + 1, function()
                                for i, note in ipairs(pendingNotes) do
                                    if note == noteData then
                                        table.remove(pendingNotes, i)
                                        break
                                    end
                                end
                            end)

                            return originalCreateNote(self, arg2, arg3, arg4)
                        end
                    end
                end)
            end
            
            hammerConnection = RunService.Heartbeat:Connect(function()
                if not autoHammerEnabled then return end
                
                local forgeGui = PlayerGui:FindFirstChild("Forge")
                if not forgeGui then return end
                
                local hammerMinigame = forgeGui:FindFirstChild("HammerMinigame")
                if not hammerMinigame or not hammerMinigame.Visible then 
                    trackedNotes = {}
                    return 
                end
                
                pcall(function()
                    -- Auto-hammer the mold
                    for _, obj in pairs(workspace.Debris:GetChildren()) do
                        if obj:IsA("Model") and obj.Name == "Mold" and obj:GetAttribute("IsDestroyed") ~= true then
                            local clickDetector = obj:FindFirstChild("ClickDetector", true)
                            if clickDetector then
                                fireclickdetector(clickDetector)
                            end
                        end
                    end
                    
                    -- Clean up old tracked notes
                    for frame, _ in pairs(trackedNotes) do
                        if not frame.Parent then
                            trackedNotes[frame] = nil
                        end
                    end
                end)
            end)
        end

        ForgeSection:AddToggle({
            Name = "Auto Hammer",
            Flag = "Forge_AutoHammer",
            Default = false,
            Callback = function(v)
                autoHammerEnabled = v
                if v then
                    startAutoHammer()
                else
                    if hammerConnection then
                        hammerConnection:Disconnect()
                        hammerConnection = nil
                    end
                end
            end
        })
    end
end

-- Run the Basic UI only in LocalPlayer environment (safety check)
if game:GetService("Players").LocalPlayer then
    createMainUI()
else
    -- Running in a non-local environment (server or runner), show instructions
    warn("[Basic] LocalPlayer not found. This script should run in a LocalScript environment inside the client.")
end

-- End of Basic script
